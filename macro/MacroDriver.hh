/*
 * Copyright (C) 2008 Dynare Team
 *
 * This file is part of Dynare.
 *
 * Dynare is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Dynare is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Dynare.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef _MACRO_DRIVER_HH
#define _MACRO_DRIVER_HH

#ifdef _PARSING_DRIVER_HH
# error Impossible to include both ParsingDriver.hh and MacroDriver.hh
#endif

#include <string>
#include <iostream>
#include <stack>
#include <map>

#include "MacroBison.hh"
#include "MacroValue.hh"

using namespace std;

// Declare MacroFlexLexer class
#ifndef __FLEX_LEXER_H
# define yyFlexLexer MacroFlexLexer
# include <FlexLexer.h>
# undef yyFlexLexer
#endif

//! The lexer class
/*! Actually it was necessary to subclass the MacroFlexLexer class generated by Flex,
    since the prototype for MacroFlexLexer::yylex() was not convenient.
*/
class MacroFlex : public MacroFlexLexer
{
private:
  //! The stack used to handle (possibly nested) includes
  /*! Keeps track of buffer state and associated location, as they were just before switching to
      included file.
      Note that we could have used yypush_buffer_state() and yypop_buffer_state()
      instead of a stack for buffer states, but those functions do not exist in Flex 2.5.4 */
  stack<pair<struct yy_buffer_state *, Macro::parser::location_type> > include_stack;

public:
  MacroFlex(istream* in = 0, ostream* out = 0);

  //! The main lexing function
  Macro::parser::token_type lex(Macro::parser::semantic_type *yylval,
                                Macro::parser::location_type *yylloc,
                                MacroDriver &driver);
};

//! Implements the macro expansion using a Flex scanner and a Bison parser
class MacroDriver
{
private:
  //! Environment: maps macro variables to their values
  map<string, MacroValue *> env;

public:
  //! Exception thrown when value of an unknown variable is requested
  class UnknownVariable
  {
  public:
    const string name;
    UnknownVariable(const string &name_arg) : name(name_arg) {}
  };

  //! Constructor
  MacroDriver();
  //! Destructor
  virtual ~MacroDriver();

  //! Starts parsing a file, returns output in out
  void parse(const string &f, ostream &out);

  //! Pointer to keep track of the input file stream currently scanned
  ifstream *ifs;

  //! Name of main file being parsed
  string file;

  //! Reference to the lexer
  class MacroFlex *lexer;

  //! Copy of output stream
  ostream *out_stream;

  //! Trace scanning ?
  /*! If set to true before calling parse(), the flex scanner will dump a lot of debugging information. Defaults to false.
  */
  bool trace_scanning;

  //! Trace parsing ?
  /*! If set to true before calling parse(), the bison parser will dump debugging information. Defaults to false. */
  bool trace_parsing;

  //! Error handler
  void error(const Macro::parser::location_type &l, const string &m) const;

  //! Set a variable
  /*! Pointer *value must not be altered nor deleted afterwards, since it is kept by this class */
  void set_variable(const string &name, MacroValue *value);

  //! Get a variable
  /*! Returns a newly allocated value (clone of the value stored in environment). */
  MacroValue *get_variable(const string &name) const throw (UnknownVariable);
};

#endif // ! MACRO_DRIVER_HH
